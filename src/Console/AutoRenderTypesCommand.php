<?php

namespace Connecttech\AutoRenderModels\Console;

use Illuminate\Console\Command;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Schema;
use Illuminate\Support\Str;
use Illuminate\Filesystem\Filesystem;
use function Laravel\Prompts\select;
use function Laravel\Prompts\confirm;

class AutoRenderTypesCommand extends Command
{
    protected $signature = 'auto-render:types
                            {--c|connection= : The database connection to use}
                            {--t|table= : The specific table to generate types for}';

    protected $description = 'Generate TypeScript interfaces from database schema';

    protected $files;

    public function __construct(Filesystem $files)
    {
        parent::__construct();
        $this->files = $files;
    }

    public function handle()
    {
        $connection = $this->option('connection') ?? config('database.default');
        
        // Interactive check
        if (!$this->option('connection') && !$this->option('table')) {
            $connections = array_keys(config('database.connections', []));
            $connection = select(
                label: 'Choose database connection:',
                options: $connections,
                default: $connection
            );
        }

        $schema = DB::connection($connection)->getSchemaBuilder();
        $tables = $schema->getTableListing();

        if ($tableName = $this->option('table')) {
             if (!in_array($tableName, $tables)) {
                $this->error("Table '$tableName' not found!");
                return;
             }
             $tables = [$tableName];
        }

        $tsContent = "// This file is automatically generated by Connecttech/AutoRenderModels.\n";
        $tsContent .= "// Do not modify directly.\n\n";

        $bar = $this->output->createProgressBar(count($tables));
        $bar->start();

        foreach ($tables as $table) {
            // Fix for SQLite/Postgres returning "schema.table" format
            if (str_contains($table, '.')) {
                $parts = explode('.', $table);
                $table = end($parts);
            }

            // Skip migration table or config excluded tables
            if ($table === 'migrations' || in_array($table, config('models.except', []))) {
                $bar->advance();
                continue;
            }

            $modelName = Str::studly(Str::singular($table));
            $columns = $schema->getColumns($table);

            $tsContent .= "export interface {$modelName} {\n";

            foreach ($columns as $column) {
                $name = $column['name'];
                
                // Configurable snake_case vs camelCase
                if (!config('models.typescript.snake_attributes', true)) {
                    $name = Str::camel($name);
                }

                $type = $this->mapTypeToTs($column['type_name']);
                $nullable = $column['nullable'] ? ' | null' : '';

                $tsContent .= "    {$name}: {$type}{$nullable};\n";
            }
            
            // Add timestamps optional if not in columns but expected? 
            // Usually getColumns gets everything, so we are good.

            $tsContent .= "}\n\n";
            $bar->advance();
        }

        $bar->finish();
        $this->newLine();

        $outputPath = config('models.typescript.path');
        $filename = config('models.typescript.filename', 'models.d.ts');
        $fullPath = rtrim($outputPath, '/') . '/' . $filename;

        if (!is_dir($outputPath)) {
            mkdir($outputPath, 0755, true);
        }

        $this->files->put($fullPath, $tsContent);

        $this->info("TypeScript interfaces generated successfully at: {$fullPath}");
    }

    protected function mapTypeToTs($dbType)
    {
        return match (Str::lower($dbType)) {
            'integer', 'int', 'smallint', 'tinyint', 'mediumint', 'bigint',
            'decimal', 'float', 'double', 'real' => 'number',
            
            'boolean', 'bool' => 'boolean',
            
            'json' => 'any',
            
            default => 'string', // varchar, text, date, datetime, timestamp, etc.
        };
    }
}
